import { JSXInternal } from 'preact/src/jsx'

class ChildComponent {
    name: string
    key: number

    constructor({ name, key }: any) {
        this.name = name
        this.key = key
    }

    render() {
        return (
            <li key={this.key}>
                {this.name}
            </li>
        )
    }
}

class ParentComponent {
    elements: any[] = [
        { id: 1, name: 'John' },
        { id: 2, name: 'Doe' },
        { id: 3, name: 'Jane' },
    ]

    render() {
        return (
            <div>
                {/* <h1>Parent Component</h1> */}
                {/* <p>This is a paragraph</p> */}
                {/* <input type="checkbox" checked={false} /> */}
                <>
                    <p>This is a paragraph inside a fragment</p>
                    {/* <p>Another paragraph inside the fragment</p> */}
                </>
                {/* {true && <p>This paragraph is conditionally rendered</p>}
                {false && <p>This paragraph is not rendered</p>}
                {null}
                {undefined}
                <ul>
                    {
                        this.elements.map((element: any) => {
                            //@ts-ignore
                            return <ChildComponent key={element.id} name={element.name} />
                        })
                    }
                </ul> */}
            </div>
        )
    }
}

const myComponent = new ParentComponent()
const template = myComponent.render()
function renderer(jsx: JSXInternal.Element | null): string {
    // @ts-ignore
    if (jsx === null || jsx === false || jsx === undefined) {
        return ''
    }

    // console.log(jsx)

    if (typeof jsx === 'string') {
        return jsx
    }

    const elementType = jsx.type

    // Fragment
    if (elementType === 'fragment') {
        const { children } = jsx.props

        if (children) {
            if (typeof children === 'string') {
                return children
            } else if (Array.isArray(children)) {
                return children.map(child => renderer(child)).join('')
            } else if (typeof children === 'function') {
                return renderer(children())
            } else {
                return Object.values(children).join('')
            }
        }

        return ''
    }

    // Normal HTML element
    if (typeof elementType === 'string') {
        let result = `<${elementType}`

        if (jsx.key) {
            result += ` key="${jsx.key}"`
        }

        const { children, ...props } = jsx.props

        // Render element attributes
        for (const key in props) {
            if (props.hasOwnProperty(key)) {
                const value = props[key]

                if (typeof value === 'boolean') {
                    // Render boolean attribute without a value if it is true
                    if (value) {
                        result += ` ${key}`
                    }
                } else {
                    // Render attribute with a value
                    result += ` ${key}="${value}"`
                }
            }
        }

        // Check if the element is self-closing
        const isSelfClosing = !children || (Array.isArray(children) && children.length === 0)

        if (isSelfClosing) {
            result += ' />'
        } else {
            result += '>'

            if (children) {
                if (typeof children === 'string') {
                    result += children
                } else if (Array.isArray(children)) {
                    result += children.map(child => renderer(child)).join('')
                } else if (typeof children === 'function') {
                    result += renderer(children())
                } else {
                    if (typeof children.type === 'function') {
                        result += renderer(children.type(children.props))
                    } else {
                        result += Object.values(children).join('')
                    }
                }
            }

            result += `</${elementType}>`
        }

        return result
    } else {
        // Custom component
        const props = jsx.props
        props.key = jsx.key
        // @ts-ignore
        const component = new elementType(props)
        return renderer(component.render())
    }
}

console.log(renderer(template))
